{"version":3,"sources":["app/decorators/filter.ts"],"names":[],"mappings":";AAAA,0CAA0C;;AAE1C,+BAA+B;AAE/B,+DAA0E;AAE1E,oDAAiD;AAUjD;;;;;;GAMG;AACH,gBAA0B,WAAwB,EAAE,UAAmC,EACrF,QAAiB;IAElB,MAAM,CAAC,UAAU,WAAwB,EAAE,GAAW;QACrD,MAAM,CAAC,iBAAiB,CAAC,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;IAC/E,CAAC,CAAC;AACH,CAAC;AAND,wBAMC;AAED;;;;;;;;GAQG;AACH,2BAAqC,WAAwB,EAAE,UAAmC,EAChG,WAAwB,EAAE,UAAmB,EAAE,QAAiB;IAEjE,IAAI,OAAe,EAClB,WAAW,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,mFAAmF;IACjH,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;QACjB,OAAO,GAAG,mBAAQ,CAAC,iBAAiB,CAAC;IACtC,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,oGAAoG;QACpG,WAAW,GAAQ,WAAW,CAAC,WAAW,CAAC;QAC3C,OAAO,GAAG,mBAAQ,CAAC,aAAa,CAAC;IAClC,CAAC;IAED,IAAI,OAAO,GAAY,WAAW;UAC/B,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC;UAC5C,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IACzD,yEAAyE;IACzE,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;IAExB,iBAAiB,CAAC,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;IAC9D,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAClE,MAAM,CAAC,WAAW,CAAC;AACpB,CAAC;AAtBD,8CAsBC;AAED;;GAEG;AACH,2BAAqC,OAAc,EAAE,WAAwB,EAAE,UAAmC,EAAE,QAAiB;IACpI,QAAQ,GAAG,QAAQ,IAAI,CAAC,CAAC;IACzB,4BAAK,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI,EAAE,EAAE,2CAA2C,CAAC,CAAC;IACnG,4BAAK,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,2CAA2C,CAAC,CAAC;IAEvG,IAAI,IAAI,GAAmB,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,EAC5D,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAA+B,EACjD,UAAU,GAAG,IAAI,CAAC,UAA4C,EAC9D,WAAW,GAAG,UAAU,CAAC,IAAI,IAAI,yBAAyB,EAC1D,cAAsB,CAAC;IAExB,4BAAK,CAAC,cAAc,CAAC,WAAW,EAAE,0CAA0C,CAAC,CAAC;IAC9E,cAAc,GAAG,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC;IAErD,uCAAuC;IACvC,cAAc;IACd,2DAA2D;IAC3D,2DAA2D;IAC3D,IAAI;IACJ,OAAO,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC5C,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC,CAAC;AACvD,CAAC;AArBD,8CAqBC","file":"filter.js","sourcesContent":["/// <reference types=\"reflect-metadata\" />\r\n\r\nimport * as acorn from 'acorn';\r\nimport * as ESTree from 'estree';\r\nimport { CriticalException, Guard, INewable } from 'back-lib-common-util';\r\n\r\nimport { MetaData } from '../constants/MetaData';\r\n\r\n\r\nexport type FilterDecorator = <T>(\r\n\t\tFilterClass: new (...param: any[]) => T,\r\n\t\tfilterFunc: (filter: T) => Function,\r\n\t\tpriority?: number\r\n\t) => Function;\r\n\r\n\r\n/**\r\n * Used to add filter to controller class and controller action.\r\n * @param {class} FilterClass Filter class whose name must end with \"Filter\".\r\n * @param {ExpressionStatement} filterFunc An arrow function that returns filter's function.\r\n * \t\tThis array function won't be executed, but is used to extract filter function name.\r\n * @param {number} priority A number from 0 to 10, filters with greater priority run before ones with less priority.\r\n */\r\nexport function filter<T>(FilterClass: INewable<T>, filterFunc: (filter: T) => Function,\r\n\t\tpriority?: number): Function {\r\n\r\n\treturn function (TargetClass: INewable<T>, key: string): Function {\r\n\t\treturn addFilterToTarget(FilterClass, filterFunc, TargetClass, key, priority);\r\n\t};\r\n}\r\n\r\n/**\r\n * Adds a filter to `TargetClass`. `TargetClass` can be a class or class prototype,\r\n * depending on whether the filter is meant to apply on class or class method.\r\n * @param FilterClass The filter class.\r\n * @param filterFunc The filter method to execute.\r\n * @param TargetClass A class or class prototype.\r\n * @param targetFunc Method name, if `TargetClass` is class prototype,\r\n * @param {number} priority A number from 0 to 10, filters with greater priority run before ones with less priority.\r\n */\r\nexport function addFilterToTarget<T>(FilterClass: INewable<T>, filterFunc: (filter: T) => Function,\r\n\t\tTargetClass: INewable<T>, targetFunc?: string, priority?: number): Function {\r\n\r\n\tlet metaKey: string,\r\n\t\tisCtrlScope = (!targetFunc); // If `key` has value, `targetClass` is \"prototype\" object, otherwise it's a class.\r\n\tif (isCtrlScope) {\r\n\t\tmetaKey = MetaData.CONTROLLER_FILTER;\r\n\t} else {\r\n\t\t// If @filter is applied to class method, the given `TargetClass` is actually the class's prototype.\r\n\t\tTargetClass = <any>TargetClass.constructor;\r\n\t\tmetaKey = MetaData.ACTION_FILTER;\r\n\t}\r\n\r\n\tlet filters: any[][] = isCtrlScope\r\n\t\t? Reflect.getOwnMetadata(metaKey, TargetClass)\r\n\t\t: Reflect.getMetadata(metaKey, TargetClass, targetFunc);\r\n\t// let filters: any[][] = Reflect.getMetadata(metaKey, TargetClass, key);\r\n\tfilters = filters || [];\r\n\r\n\tpushFilterToArray(filters, FilterClass, filterFunc, priority);\r\n\tReflect.defineMetadata(metaKey, filters, TargetClass, targetFunc);\r\n\treturn TargetClass;\r\n}\r\n\r\n/**\r\n * Prepares a filter then push it to given array.\r\n */\r\nexport function pushFilterToArray<T>(filters: any[], FilterClass: INewable<T>, filterFunc: (filter: T) => Function, priority?: number): void {\r\n\tpriority = priority || 5;\r\n\tGuard.assertIsTruthy(priority >= 1 && priority <= 10, 'Filter priority must be between 1 and 10.');\r\n\tGuard.assertIsTruthy(FilterClass.name.endsWith('Filter'), 'Filter class name must end with \"Filter\".');\r\n\r\n\tlet func: ESTree.Program = acorn.parse(filterFunc.toString()),\r\n\t\tbody = func.body[0] as ESTree.ExpressionStatement,\r\n\t\texpression = body.expression as ESTree.ArrowFunctionExpression,\r\n\t\tisArrowFunc = expression.type == 'ArrowFunctionExpression',\r\n\t\tfilterFuncName: string;\r\n\r\n\tGuard.assertIsTruthy(isArrowFunc, '`filterFunc` must be an arrow statement.');\r\n\tfilterFuncName = expression.body['property']['name'];\r\n\r\n\t// `filters` is a 3-dimensioned matrix:\r\n\t// filters = [\r\n\t//\t\t1: [ [FilterClass, funcName], [FilterClass, funcName] ]\r\n\t//\t\t5: [ [FilterClass, funcName], [FilterClass, funcName] ]\r\n\t// ]\r\n\tfilters[priority] = filters[priority] || [];\r\n\tfilters[priority].push([FilterClass, filterFuncName]);\r\n}"]}