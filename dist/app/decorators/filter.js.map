{"version":3,"sources":["app/decorators/filter.ts"],"names":[],"mappings":";AAAA,0CAA0C;;AAE1C,+BAA+B;AAE/B,+DAA0E;AAE1E,oDAAiD;AAUjD;;;;;;GAMG;AACH,gBAA0B,WAAwB,EAAE,UAAmC,EACrF,QAAiB;IAElB,MAAM,CAAC,UAAU,WAAwB,EAAE,GAAW;QACrD,mFAAmF;QACnF,IAAI,OAAe,EAClB,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACtB,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACjB,OAAO,GAAG,mBAAQ,CAAC,iBAAiB,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,WAAW,GAAQ,WAAW,CAAC,WAAW,CAAC;YAC3C,OAAO,GAAG,mBAAQ,CAAC,aAAa,CAAC;QAClC,CAAC;QAED,IAAI,OAAO,GAAY,WAAW;cAC/B,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC;cAC5C,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;QAClD,yEAAyE;QACzE,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QAExB,gBAAgB,CAAC,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC7D,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;QAE3D,MAAM,CAAC,WAAW,CAAC;IACpB,CAAC,CAAC;AACH,CAAC;AAzBD,wBAyBC;AAED,0BAAoC,OAAc,EAAE,WAAwB,EAAE,UAAmC,EAAE,QAAiB;IACnI,QAAQ,GAAG,QAAQ,IAAI,CAAC,CAAC;IACzB,4BAAK,CAAC,cAAc,CAAC,QAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI,EAAE,EAAE,2CAA2C,CAAC,CAAC;IACnG,4BAAK,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,2CAA2C,CAAC,CAAC;IAEvG,IAAI,IAAI,GAAmB,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,EAC5D,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAA+B,EACjD,UAAU,GAAG,IAAI,CAAC,UAA4C,EAC9D,WAAW,GAAG,UAAU,CAAC,IAAI,IAAI,yBAAyB,EAC1D,cAAsB,CAAC;IAExB,4BAAK,CAAC,cAAc,CAAC,WAAW,EAAE,0CAA0C,CAAC,CAAC;IAC9E,cAAc,GAAG,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC;IAErD,yBAAyB;IACzB,0BAA0B;IAC1B,0BAA0B;IAC1B,OAAO,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC5C,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;AACrD,CAAC;AAnBD,4CAmBC","file":"filter.js","sourcesContent":["/// <reference types=\"reflect-metadata\" />\r\n\r\nimport * as acorn from 'acorn';\r\nimport * as ESTree from 'estree';\r\nimport { CriticalException, Guard, INewable } from 'back-lib-common-util';\r\n\r\nimport { MetaData } from '../constants/MetaData';\r\n\r\n\r\nexport type FilterDecorator = <T>(\r\n\t\tFilterClass: new (...param: any[]) => T,\r\n\t\tfilterFunc: (filter: T) => Function,\r\n\t\tpriority?: number\r\n\t) => Function;\r\n\r\n\r\n/**\r\n * Used to add filter to controller class and controller action.\r\n * @param {class} FilterClass Filter class whose name must end with \"Filter\".\r\n * @param {ExpressionStatement} filterFunc An arrow function that returns filter's function.\r\n * \t\tThis array function won't be executed, but is used to extract filter function name.\r\n * @param {number} priority A number from 0 to 10, filters with greater priority run before ones with less priority.\r\n */\r\nexport function filter<T>(FilterClass: INewable<T>, filterFunc: (filter: T) => Function,\r\n\t\tpriority?: number): Function {\r\n\r\n\treturn function (TargetClass: INewable<T>, key: string): Function {\r\n\t\t// If `key` has value, `targetClass` is \"prototype\" object, otherwise it's a class.\r\n\t\tlet metaKey: string,\r\n\t\t\tisCtrlScope = (!key);\r\n\t\tif (isCtrlScope) {\r\n\t\t\tmetaKey = MetaData.CONTROLLER_FILTER;\r\n\t\t} else {\r\n\t\t\tTargetClass = <any>TargetClass.constructor;\r\n\t\t\tmetaKey = MetaData.ACTION_FILTER;\r\n\t\t}\r\n\r\n\t\tlet filters: any[][] = isCtrlScope\r\n\t\t\t? Reflect.getOwnMetadata(metaKey, TargetClass)\r\n\t\t\t: Reflect.getMetadata(metaKey, TargetClass, key);\r\n\t\t// let filters: any[][] = Reflect.getMetadata(metaKey, TargetClass, key);\r\n\t\tfilters = filters || [];\r\n\r\n\t\taddFilterToArray(filters, FilterClass, filterFunc, priority);\r\n\t\tReflect.defineMetadata(metaKey, filters, TargetClass, key);\r\n\r\n\t\treturn TargetClass;\r\n\t};\r\n}\r\n\r\nexport function addFilterToArray<T>(filters: any[], FilterClass: INewable<T>, filterFunc: (filter: T) => Function, priority?: number): void {\r\n\tpriority = priority || 5;\r\n\tGuard.assertIsTruthy(priority >= 1 && priority <= 10, 'Filter priority must be between 1 and 10.');\r\n\tGuard.assertIsTruthy(FilterClass.name.endsWith('Filter'), 'Filter class name must end with \"Filter\".');\r\n\r\n\tlet func: ESTree.Program = acorn.parse(filterFunc.toString()),\r\n\t\tbody = func.body[0] as ESTree.ExpressionStatement,\r\n\t\texpression = body.expression as ESTree.ArrowFunctionExpression,\r\n\t\tisArrowFunc = expression.type == 'ArrowFunctionExpression',\r\n\t\tfilterFuncName: string;\r\n\r\n\tGuard.assertIsTruthy(isArrowFunc, '`filterFunc` must be an arrow statement.');\r\n\tfilterFuncName = expression.body['property']['name'];\r\n\r\n\t// `filters` is a matrix:\r\n\t// 1: [Filter_1, Filter_2]\r\n\t// 5: [Filter_3, Filter_4]\r\n\tfilters[priority] = filters[priority] || [];\r\n\tfilters[priority].push(FilterClass, filterFuncName);\r\n}"]}